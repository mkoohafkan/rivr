<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Derivations used in rivr • rivr</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Derivations used in rivr">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">


    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">rivr</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">1.2-3</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles

    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/publication-reproduction.html">Reproducing the R Journal Publication</a>
    </li>
    <li>
      <a href="../articles/quickstart.html">Quickstart with rivr</a>
    </li>
    <li>
      <a href="../articles/technical-vignette.html">Derivations used in rivr</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/mkoohafkan/rivr/" class="external-link">
    <span class="fab fa-github fa-lg"></span>

  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->



      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Derivations used in rivr</h1>
                        <h4 data-toc-skip class="author">Michael
Koohafkan</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/mkoohafkan/rivr/blob/master/vignettes/technical-vignette.Rmd" class="external-link"><code>vignettes/technical-vignette.Rmd</code></a></small>
      <div class="hidden name"><code>technical-vignette.Rmd</code></div>

    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>This vignette documents the mathematical derivations for
gradually-varied and unsteady flow analysis with <code>rivr</code>. All
derivations are based on <a href="https://www.springer.com/us/book/9780387301747" title="Chaudhry, M. H. (2007). Open-channel flow. Springer Science &amp; Business Media." class="external-link">Chaudry
(2007)</a>. In Section 1, important definitions related to channel
geometry are discussed. In Section 2, basic concepts of open-channel
flow are discussed and one-dimensional shallow-water equations are
derived. In Section 3, gradually-varied flow is derived and the
standard-step method is discussed. In Section 4, the kinematic and
dynamic wave models for simulating unsteady flow are derived along with
the three discretization methods available in <code>rivr</code>.
Finally, Section 5 discusses the Method of Characteristics and its
application to boundary conditions of unsteady flow simulations.</p>
</div>
<div class="section level2">
<h2 id="section-1-channel-geometry-relations">Section 1: Channel geometry relations<a class="anchor" aria-label="anchor" href="#section-1-channel-geometry-relations"></a>
</h2>
<p><img src="channeldiagram.png" title="Cross-section of a trapezoidal channel."></p>
<p>A channel is <em>prismatic</em> if it has the same slope and
cross-section throughout its entire length. The <code>rivr</code>
package currently supports prismatic trapezoidal channels of arbitrary
bottom width
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
and side slope
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>S</mi><mo>=</mo><mi>H</mi><mo>:</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">SS = H:V</annotation></semantics></math>.
Given a flow depth
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>,
the flow area is then
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi><mi>y</mi><mo>+</mo><mi>S</mi><mi>S</mi><msup><mi>y</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
A = By + SSy^2
</annotation></semantics></math> Another important definition is the
wetted perimeter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>,
which for a trapezoidal cross-section is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mi>B</mi><mo>+</mo><mn>2</mn><mi>y</mi><msqrt><mrow><mn>1</mn><mo>+</mo><mi>S</mi><msup><mi>S</mi><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">
P = B + 2y\sqrt{1 + SS^2}
</annotation></semantics></math> The hydraulic radius is the ratio of
the cross-sectional flow area to the wetted perimeter, i.e.
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mfrac><mi>A</mi><mi>P</mi></mfrac></mrow><annotation encoding="application/x-tex">
R = \frac{A}{P}
</annotation></semantics></math> The hydraulic depth
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
is defined as the ratio of the cross-sectional flow area to the top
width
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>,
where
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>A</mi></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
T = \frac{dA}{dy}
</annotation></semantics></math> which for a trapezoidal cross-section
yields
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mi>B</mi><mo>+</mo><mn>2</mn><mi>y</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">
T = B + 2ySS
</annotation></semantics></math> and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>=</mo><mfrac><mi>A</mi><mi>T</mi></mfrac><mo>=</mo><mfrac><mrow><mi>B</mi><mi>y</mi><mo>+</mo><mi>S</mi><mi>S</mi><msup><mi>y</mi><mn>2</mn></msup></mrow><mrow><mi>B</mi><mo>+</mo><mn>2</mn><mi>y</mi><mi>S</mi><mi>S</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
D = \frac{A}{T} = \frac{By + SSy^2}{B + 2ySS}
</annotation></semantics></math> Finally, the term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>y</mi><mo accent="true">‾</mo></mover><annotation encoding="application/x-tex">\bar{y}</annotation></semantics></math>
is related to hydrostatic pressure and is defined as the distance from
the water surface to the centroid of the cross-sectional flow area, i.e.
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>y</mi><mo accent="true">‾</mo></mover><mo>=</mo><mfrac><mrow><mn>2</mn><mi>B</mi><mo>+</mo><mi>T</mi></mrow><mrow><mn>3</mn><mrow><mo stretchy="true" form="prefix">(</mo><mi>B</mi><mo>+</mo><mi>T</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mi>y</mi></mrow><annotation encoding="application/x-tex">
\bar{y} = \frac{2B + T}{3(B + T)} y
</annotation></semantics></math></p>
<p>The definitions described above are fundamental properties related to
one-dimensional open-channel flow. These relations (and their
derivatives) are used extensively in the following sections to derive
important flow relations and appear repeatedly in numerical solution
schemes.</p>
</div>
<div class="section level2">
<h2 id="section-2-basic-concepts-of-one-dimensional-open-channel-flow">Section 2: Basic concepts of one-dimensional open-channel flow<a class="anchor" aria-label="anchor" href="#section-2-basic-concepts-of-one-dimensional-open-channel-flow"></a>
</h2>
<p>The flow depth of a channel in an equilibrium state is called the
<em>normal depth</em>, i.e. the flow depth at which gravitational forces
(bed slope) are balanced by friction forces (bed roughness). The
<code>rivr</code> package expresses the normal depth via the
semi-empirical Manning’s equation
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mfrac><msub><mi>C</mi><mi>m</mi></msub><mi>n</mi></mfrac><mi>A</mi><msup><mi>R</mi><mrow><mn>2</mn><mi>/</mi><mn>3</mn></mrow></msup><msubsup><mi>S</mi><mn>0</mn><mrow><mn>1</mn><mi>/</mi><mn>2</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">
Q = \frac{C_m}{n} AR^{2/3}S_0^{1 / 2}
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>
is the channel flow,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>S</mi><mn>0</mn></msub><annotation encoding="application/x-tex">S_0</annotation></semantics></math>
is the channel slope,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is the cross-sectional flow area,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
is the hydraulic depth and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mi>m</mi></msub><annotation encoding="application/x-tex">C_m</annotation></semantics></math>
is a conversion factor based on the unit system used (1.49 in US
customary units and 1.0 in SI units). The expression is often rewritten
as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>K</mi><msubsup><mi>S</mi><mn>0</mn><mrow><mn>1</mn><mi>/</mi><mn>2</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">
Q = KS_0^{1 / 2}
</annotation></semantics></math> Where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
is the <em>channel conveyance</em>. The normal depth
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>n</mi></msub><annotation encoding="application/x-tex">y_n</annotation></semantics></math>
factors into the expressions of both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
(i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>)
and the above equation cannot be rearranged to solved explicitly for the
normal depth; an implicit (iterative) solution is needed. The univariate
Netwon-Raphson method is often used to provide efficient and precise
solutions for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>n</mi></msub><annotation encoding="application/x-tex">y_n</annotation></semantics></math>.
Generally, the Newton-Raphson method is defined as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><msup><mi>x</mi><mo>*</mo></msup><mo>−</mo><mfrac><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>x</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mfrac><mrow><mi>d</mi><mi>f</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><msub><mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">|</mo><msup><mi>x</mi><mo>*</mo></msup></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">
x = x^* - \frac{f(x^*)}{\frac{df}{dx}\bigg|_{x^*}}
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
is the updated guess for the parameter for which a solution is sought,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>x</mi><mo>*</mo></msup><annotation encoding="application/x-tex">x^*</annotation></semantics></math>
is the prior guess for the parameter value,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math>
is a zero-valued function of the parameter and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>d</mi><mi>f</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{df}{dx}</annotation></semantics></math>
is the derivative of said function. To apply the Newton-Raphson method
here, Manning’s equation is rewritten as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>A</mi><msup><mi>R</mi><mrow><mn>2</mn><mi>/</mi><mn>3</mn></mrow></msup><mo>−</mo><mfrac><mrow><mi>n</mi><mi>Q</mi></mrow><mrow><msub><mi>C</mi><mi>m</mi></msub><msubsup><mi>S</mi><mn>0</mn><mrow><mn>1</mn><mi>/</mi><mn>2</mn></mrow></msubsup></mrow></mfrac><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">
f(y_n) = AR^{2/3} - \frac{nQ}{C_m S_0^{1 / 2}} = 0
</annotation></semantics></math> and its derivative is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>f</mi></mrow><mrow><mi>d</mi><msub><mi>y</mi><mi>n</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mn>5</mn><mn>3</mn></mfrac><mi>T</mi><msup><mi>R</mi><mrow><mn>2</mn><mi>/</mi><mn>3</mn></mrow></msup><mo>−</mo><mfrac><mn>2</mn><mn>3</mn></mfrac><msup><mi>R</mi><mrow><mn>5</mn><mi>/</mi><mn>3</mn></mrow></msup><mfrac><mrow><mi>d</mi><mi>P</mi></mrow><mrow><mi>d</mi><msub><mi>y</mi><mi>n</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\frac{df}{dy_n} = \frac{5}{3}T R^{2/3} - \frac{2}{3}R^{5/3}\frac{dP}{dy_n}
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>P</mi></mrow><mrow><mi>d</mi><msub><mi>y</mi><mi>n</mi></msub></mrow></mfrac><mo>=</mo><mn>2</mn><msqrt><mrow><mn>1</mn><mo>+</mo><mi>S</mi><msup><mi>S</mi><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">\frac{dP}{dy_n} = 2\sqrt{1 + SS^2}</annotation></semantics></math>.
A related concept is the <em>critical depth</em>, the flow depth which
minimizes the specific energy of the flow. The specific energy is the
sum of flow depth and velocity head, i.e.
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mi>y</mi><mo>+</mo><mfrac><msup><mi>u</mi><mn>2</mn></msup><mrow><mn>2</mn><mi>g</mi></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>g</mi></mrow></mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mi>Q</mi><mi>A</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
E = y + \frac{u^2}{2g} = \frac{1}{2g}\left(\frac{Q}{A}\right)^2
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math>
is the uniform flow velocity. The critical depth is then the flow depth
that satisfies
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>E</mi></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><mo>=</mo><mn>0</mn><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><msup><mi>Q</mi><mn>2</mn></msup><mrow><mi>g</mi><msup><mi>A</mi><mn>3</mn></msup></mrow></mfrac><mfrac><mrow><mi>d</mi><mi>A</mi></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><mrow><msup><mi>Q</mi><mn>2</mn></msup><mi>T</mi></mrow><mrow><mi>g</mi><msup><mi>A</mi><mn>3</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\frac{dE}{dy} = 0 = 1 - \frac{Q^2}{gA^3}\frac{dA}{dy} = 1 - \frac{Q^2 T}{gA^3}
</annotation></semantics></math> For a trapezoidal channel it can be
mathematically proved that only one critical depth exists for a given
flow rate. The critical depth can be solved using the Newton-Raphson
method with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>c</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><mi>d</mi><mi>E</mi></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(y_c) = \frac{dE}{dy} = 0</annotation></semantics></math>
and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>f</mi></mrow><mrow><mi>d</mi><msub><mi>y</mi><mi>c</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mn>3</mn><mn>2</mn></mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mi>T</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>1</mn><mi>/</mi><mn>2</mn></mrow></msup><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mi>A</mi><mi>T</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>3</mn><mi>/</mi><mn>2</mn></mrow></msup><mfrac><mrow><mi>d</mi><mi>T</mi></mrow><mrow><mi>d</mi><msub><mi>y</mi><mi>c</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\frac{df}{dy_c} = \frac{3}{2}\left(AT\right)^{1 / 2} - \frac{1}{2}\left(\frac{A}{T}\right)^{3/2}\frac{dT}{dy_c}
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>T</mi></mrow><mrow><mi>d</mi><msub><mi>y</mi><mi>c</mi></msub></mrow></mfrac><mo>=</mo><mn>2</mn><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">\frac{dT}{dy_c} = 2SS</annotation></semantics></math>
for a trapezoidal channel. The critical depth is also the depth at which
the <em>Froude number</em> of the flow is unity; the Froude number is a
dimensionless measure of bulk flow characteristics that represents the
relative importance of inertial forces and gravitational forces and is
defined as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>r</mi><mo>=</mo><mfrac><mi>Q</mi><mrow><mi>A</mi><msqrt><mrow><mi>g</mi><mi>D</mi></mrow></msqrt></mrow></mfrac></mrow><annotation encoding="application/x-tex">
Fr = \frac{Q}{A\sqrt{gD}}
</annotation></semantics></math></p>
<p>Flows are referred to as <em>subcritical</em> if the flow depth is
greater than the critical depth
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>r</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">Fr &lt; 1</annotation></semantics></math>)
and <em>supercritical</em> if the flow depth is less than the critical
depth
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>r</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">Fr &gt; 1</annotation></semantics></math>).
Flows can transition gradually from subcritical to supercritical
conditions; when the rate of variation of flow depth is small with
respect to the longitudinal distance over which the change occurs, the
river state is referred to as <em>gradually-varied flow</em>. In
contrast, the transition from supercritical to subcritical conditions
occur abruptly in the form of a hydraulic jump and is an example of
<em>rapidly-varied flow</em>. Both gradually-varied and rapidly-varied
flows can be either steady (flow is constant through time) or unsteady
(flow rate varies with respect to time). The <code>rivr</code> package
provides solutions for steady gradually-varied and unsteady flow
problems.</p>
</div>
<div class="section level2">
<h2 id="section-3-solutions-to-steady-gradually-varied-flow-problems">Section 3: Solutions to steady gradually-varied flow problems<a class="anchor" aria-label="anchor" href="#section-3-solutions-to-steady-gradually-varied-flow-problems"></a>
</h2>
<p>The <em>standard-step method</em> can be used to solve the steady
gradually-varied flow profile when the channel flow and geometry are
known. Additionally, the flow depth
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
must be known at a specified channel cross-section; this cross-section
is referred to as the <em>control section</em> and the flow depth
associated with the channel flow rate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>
at the control section is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mn>1</mn></msub><annotation encoding="application/x-tex">y_1</annotation></semantics></math>.
The total head
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>1</mn></msub><annotation encoding="application/x-tex">H_1</annotation></semantics></math>
at the control section is the sum of the elevation head, flow depth
head, and velocity head, i.e.
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>=</mo><msub><mi>y</mi><mn>1</mn></msub><mo>+</mo><msub><mi>z</mi><mn>1</mn></msub><mo>+</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>g</mi></mrow></mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mi>Q</mi><msub><mi>A</mi><mn>1</mn></msub></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>=</mo><msub><mi>z</mi><mn>1</mn></msub><mo>+</mo><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">
H_1 = y_1 + z_1 + \frac{1}{2g}\left(\frac{Q}{A_1}\right)^2 = z_1 + E_1
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>z</mi><mn>1</mn></msub><annotation encoding="application/x-tex">z_1</annotation></semantics></math>
is the elevation of the control section bottom relative to some datum
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mn>1</mn></msub><annotation encoding="application/x-tex">A_1</annotation></semantics></math>
is the cross-sectional flow area at the control section. From
conservation of energy, it follows that the total head
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>2</mn></msub><annotation encoding="application/x-tex">H_2</annotation></semantics></math>
at some downstream cross-section, referred to as the <em>target
section</em>, is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>2</mn></msub><mo>=</mo><msub><mi>H</mi><mn>1</mn></msub><mo>−</mo><msub><mi>h</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">
H_2 = H_1 - h_f
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>h</mi><mi>f</mi></msub><annotation encoding="application/x-tex">h_f</annotation></semantics></math>
is the head loss. While the head loss term generally combines both
friction loss and form drag, the latter component is neglected by
<code>rivr</code>. The friction component is expressed as the average
friction slope between the control and target sections:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>f</mi></msub><mo>=</mo><mfrac><mrow><msub><msub><mi>S</mi><mi>f</mi></msub><mn>1</mn></msub><mo>+</mo><msub><msub><mi>S</mi><mi>f</mi></msub><mn>2</mn></msub></mrow><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
h_f = \frac{{S_f}_1 + {S_f}_2}{2} \left(x_2 - x_1\right)
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_2 - x_1</annotation></semantics></math>
is the longitudinal distance between the control and target section.
Note that the sign of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>h</mi><mi>f</mi></msub><annotation encoding="application/x-tex">h_f</annotation></semantics></math>
therefore depends on whether the control section is upstream
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1 &lt; x_2</annotation></semantics></math>)
or downstream
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>&gt;</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1 &gt; x_2</annotation></semantics></math>)
of the target section. Substituting these terms into the governing
equation and rearranging yields
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>+</mo><msub><mi>z</mi><mn>2</mn></msub><mo>+</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>g</mi></mrow></mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mi>Q</mi><msub><mi>A</mi><mn>2</mn></msub></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>+</mo><mfrac><mrow><msub><msub><mi>S</mi><mi>f</mi></msub><mn>1</mn></msub><mo>+</mo><msub><msub><mi>S</mi><mi>f</mi></msub><mn>2</mn></msub></mrow><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>y</mi><mn>1</mn></msub><mo>+</mo><msub><mi>z</mi><mn>1</mn></msub><mo>+</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>g</mi></mrow></mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mi>Q</mi><msub><mi>A</mi><mn>1</mn></msub></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
y_2 + z_2 + \frac{1}{2g}\left(\frac{Q}{A_2}\right)^2 + \frac{{S_f}_1 + {S_f}_2}{2} \left(x_2 - x_1\right) = y_1 + z_1 + \frac{1}{2g}\left(\frac{Q}{A_1}\right)^2
</annotation></semantics></math> Note that all terms on the right-hand
side of the equation are known, while
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mn>2</mn></msub><annotation encoding="application/x-tex">A_2</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><msub><mi>S</mi><mi>f</mi></msub><mn>2</mn></msub><annotation encoding="application/x-tex">{S_f}_2</annotation></semantics></math>
on the left-hand side of the equation are functions of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mn>2</mn></msub><annotation encoding="application/x-tex">y_2</annotation></semantics></math>.
Transposing all terms to the left-hand side yields a zero-value function
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mn>2</mn></msub><annotation encoding="application/x-tex">y_2</annotation></semantics></math>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn><mo>=</mo><msub><mi>y</mi><mn>2</mn></msub><mo>+</mo><msub><mi>z</mi><mn>2</mn></msub><mo>+</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>g</mi></mrow></mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mi>Q</mi><msub><mi>A</mi><mn>2</mn></msub></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>+</mo><mfrac><mrow><msub><msub><mi>S</mi><mi>f</mi></msub><mn>1</mn></msub><mo>+</mo><msub><msub><mi>S</mi><mi>f</mi></msub><mn>2</mn></msub></mrow><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><mo>−</mo><msub><mi>z</mi><mn>1</mn></msub><mo>−</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>g</mi></mrow></mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mi>Q</mi><msub><mi>A</mi><mn>1</mn></msub></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
f(y_2) = 0 = y_2 + z_2 + \frac{1}{2g}\left(\frac{Q}{A_2}\right)^2 + \frac{{S_f}_1 + {S_f}_2}{2} \left(x_2 - x_1\right) - y_1 - z_1 - \frac{1}{2g}\left(\frac{Q}{A_1}\right)^2
</annotation></semantics></math> This function is suitable for solving
using the Newton-Raphson method discussed previously, i.e.
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>=</mo><msubsup><mi>y</mi><mn>2</mn><mo>*</mo></msubsup><mo>−</mo><mfrac><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>y</mi><mn>2</mn><mo>*</mo></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mfrac><mrow><mi>d</mi><mi>f</mi></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><msub><mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">|</mo><msubsup><mi>y</mi><mn>2</mn><mo>*</mo></msubsup></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">
y_2 = y_2^* - \frac{f(y_2^*)}{\frac{df}{dy}\bigg|_{y_2^*}}
</annotation></semantics></math> where
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>f</mi></mrow><mrow><mi>d</mi><msub><mi>y</mi><mn>2</mn></msub></mrow></mfrac><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><msup><mi>Q</mi><mn>2</mn></msup><mrow><mi>g</mi><msubsup><mi>A</mi><mn>2</mn><mn>3</mn></msubsup></mrow></mfrac><mfrac><mrow><mi>d</mi><msub><mi>A</mi><mn>2</mn></msub></mrow><mrow><mi>d</mi><msub><mi>y</mi><mn>2</mn></msub></mrow></mfrac><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mfrac><mrow><mi>d</mi><msub><msub><mi>S</mi><mi>f</mi></msub><mn>2</mn></msub></mrow><mrow><mi>d</mi><msub><mi>y</mi><mn>2</mn></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\frac{df}{dy_2} = 1 - \frac{Q^2}{gA_2^3}\frac{dA_2}{dy_2} + \frac{1}{2}\left(x_2 - x_1\right) \frac{d{S_f}_2}{dy_2}
</annotation></semantics></math> and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><msub><msub><mi>S</mi><mi>f</mi></msub><mn>2</mn></msub></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><mo>=</mo><mo>−</mo><mn>2</mn><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msub><msub><mi>S</mi><mi>f</mi></msub><mn>2</mn></msub><mi>A</mi></mfrac><mfrac><mrow><mi>d</mi><mi>A</mi></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><mo>+</mo><mfrac><mn>2</mn><mn>3</mn></mfrac><mfrac><msub><msub><mi>S</mi><mi>f</mi></msub><mn>2</mn></msub><mi>R</mi></mfrac><mfrac><mrow><mi>d</mi><mi>R</mi></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\frac{d{S_f}_2}{dy} = -2\left(\frac{{S_f}_2}{A} \frac{dA}{dy} + \frac{2}{3} \frac{{S_f}_2}{R} \frac{dR}{dy} \right)
</annotation></semantics></math> Once the flow depth at the target
section is found, the target section becomes the new control section and
the flow depth at the next target section is computed, with the
algorithm “stepping” up or down the channel to a specified distance from
the initial control section. The standard-step method is accessed via
the function <code>compute_profile</code>.</p>
</div>
<div class="section level2">
<h2 id="section-4-solutions-to-unsteady-flow-problems">Section 4: Solutions to unsteady-flow problems<a class="anchor" aria-label="anchor" href="#section-4-solutions-to-unsteady-flow-problems"></a>
</h2>
<p>Unsteady flow problems are generally characterized using the Shallow
Water Equations, with the one-dimensional form expressed as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>∂</mi><mi>A</mi></mrow><mrow><mi>∂</mi><mi>t</mi></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>∂</mi><mi>Q</mi></mrow><mrow><mi>∂</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">
\frac{\partial A}{\partial t} + \frac{\partial Q}{\partial x} = 0
</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>∂</mi><mi>Q</mi></mrow><mrow><mi>∂</mi><mi>t</mi></mrow></mfrac><mo>+</mo><mfrac><mi>∂</mi><mrow><mi>∂</mi><mi>x</mi></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mi>Q</mi><mi>u</mi><mo>+</mo><mi>g</mi><mover><mi>y</mi><mo accent="true">‾</mo></mover><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>g</mi><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>S</mi><mn>0</mn></msub><mo>−</mo><msub><mi>S</mi><mi>f</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">
\frac{\partial Q}{\partial t} + \frac{\partial}{\partial x} \left(Qu + g\bar{y}A\right) - gA\left(S_0 - S_f\right) = 0
</annotation></semantics></math> where the first equation expresses mass
conservation and the second expresses momentum conservation. Without
further simplification, these equations are often referred to as the
Dynamic Wave Model (DWM). The Kinematic Wave Model (KWM) refers to a
simplification of the momentum equation by assuming
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub><mo>=</mo><msub><mi>S</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">S_0 = S_f</annotation></semantics></math>,
i.e. the momentum equation is instead expressed through the relation
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mi>n</mi><mi>Q</mi><msup><mi>P</mi><mrow><mn>2</mn><mi>/</mi><mn>3</mn></mrow></msup></mrow><mrow><msub><mi>C</mi><mi>m</mi></msub><msubsup><mi>S</mi><mn>0</mn><mrow><mn>1</mn><mi>/</mi><mn>2</mn></mrow></msubsup></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>3</mn><mi>/</mi><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">
A = \left( \frac{nQP^{2/3}}{C_m S_0^{1 / 2}} \right)^{3/5}
</annotation></semantics></math> Both the KWM and DWM can be solved
using numerical discretization methods such as finite-difference
schemes. Finite-difference schemes discretize a continuous model domain
into a series of <em>nodes</em> separated by an incremental distance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Δ</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\Delta x</annotation></semantics></math>.
The model time domain is similarly discretized into a series of time
steps separated by an incremental time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\Delta t</annotation></semantics></math>.
A finite-difference scheme is called <em>explicit</em> if the value of
the variable being solved for on time step
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k + 1</annotation></semantics></math>
depends explicitly on the value of the variable at the previous time
step
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>.
Explicit methods are advantageous because they are easier to program and
implement, but are disadvantageous because they are subject to stability
constraints. The stability constraint is defined by the Courant number
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mfrac><mrow><mi>Δ</mi><mi>t</mi></mrow><mrow><mi>Δ</mi><mi>x</mi></mrow></mfrac><mi>u</mi></mrow><annotation encoding="application/x-tex">
C = \frac{\Delta t}{\Delta x} u
</annotation></semantics></math> which represents the ratio of the flow
velocity to the rate of propagation of information through the model
domain. The numerical solution is unstable if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">C &gt; 1</annotation></semantics></math>.</p>
<p>The <code>rivr</code> package provides an interface to one
finite-difference numerical scheme for the KWM and two finite-difference
schemes for the DWM. In addition, the DWM interface supports boundary
condition solutions using the Method of Characteristics (MOC). These
schemes are accessed via the function <code>route_wave</code> and their
derivations are discussed below.</p>
<div class="section level3">
<h3 id="solution-to-the-kinematic-wave-model">Solution to the Kinematic Wave Model<a class="anchor" aria-label="anchor" href="#solution-to-the-kinematic-wave-model"></a>
</h3>
<p>The KWM finite-difference scheme implemented in <code>rivr</code>
requires a constant time step and spatial resolution, a known upstream
boundary condition (flow) for the full simulation time, and an initial
condition (flow) at every node. The initial water depth, flow area, and
flow velocity are calculated from the channel geometry relations, with
the initial water depth assumed to be the normal depth. At the
initiation of a new time step
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k + 1</annotation></semantics></math>,
the flow at the upstream boundary node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = 1</annotation></semantics></math>
is assigned from the user-supplied boundary condition. The flow depth at
the upstream boundary is calculated as the normal depth for that flow,
i.e.
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>y</mi><mn>1</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><msub><mi>y</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>Q</mi><mn>1</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
y_1^{k+1} = y_n\left(Q_1^{k+1}\right) 
</annotation></semantics></math> where the superscripts denote the
timestep. The flow at a downstream node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
is computed as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Q</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><msubsup><mi>Q</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>−</mo><mfrac><mrow><mi>Δ</mi><mi>x</mi></mrow><mrow><mi>Δ</mi><mi>t</mi></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>A</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>−</mo><msubsup><mi>A</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
Q_i^{k+1} = Q^{k+1}_{i - 1} - \frac{\Delta x}{\Delta t}\left( A_{i-1}^{k+1} - A_{i-1}^{k}\right)
</annotation></semantics></math> where the subscripts denote the node.
The flow depth at node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
is calculated using a Newton-Raphson formulation where
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>y</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn><mo>=</mo><msubsup><mi>A</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>−</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mi>n</mi><msubsup><mi>Q</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow><mrow><msub><mi>C</mi><mi>m</mi></msub><msubsup><mi>S</mi><mn>0</mn><mrow><mn>1</mn><mi>/</mi><mn>2</mn></mrow></msubsup></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>3</mn><mi>/</mi><mn>5</mn></mrow></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>P</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>2</mn><mi>/</mi><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">
f(y_i^{k+1}) = 0 = A_i^{k+1} - \left(\frac{nQ_i^{k+1}}{C_m S_0^{1 / 2}}\right)^{3/5} \left(P_i^{k+1}\right)^{2/5} 
</annotation></semantics></math><br>
and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>f</mi></mrow><mrow><mi>d</mi><msubsup><mi>y</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>d</mi><mi>A</mi></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><msub><mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">|</mo><msubsup><mi>y</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup></msub><mo>−</mo><mfrac><mn>2</mn><mn>5</mn></mfrac><mfrac><mrow><mi>d</mi><mi>P</mi></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><msub><mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">|</mo><msubsup><mi>y</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup></msub><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mi>n</mi><msubsup><mi>Q</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow><mrow><msub><mi>C</mi><mi>m</mi></msub><msubsup><mi>S</mi><mn>0</mn><mrow><mn>1</mn><mi>/</mi><mn>2</mn></mrow></msubsup><msubsup><mi>P</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>3</mn><mi>/</mi><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">
\frac{df}{dy_i^{k+1}} = \frac{dA}{dy}\bigg|_{y_i^{k+1}} - \frac{2}{5}\frac{dP}{dy}\bigg|_{y_i^{k+1}} \left( \frac{nQ_i^{k+1}}{C_m S_0^{1 / 2} P_i^{k+1}} \right)^{3/5}
</annotation></semantics></math> Once the flow depth is known, the
remaining geometry relations can be computed and the algorithm moves to
the next downstream node. The algorithm advances to the next time step
once all nodes are computed.</p>
</div>
<div class="section level3">
<h3 id="solution-to-the-dynamic-wave-model-the-lax-diffusive-scheme">Solution to the Dynamic Wave Model: the Lax diffusive scheme<a class="anchor" aria-label="anchor" href="#solution-to-the-dynamic-wave-model-the-lax-diffusive-scheme"></a>
</h3>
<p>The set of equations describing the DWM are more complex than the
KWM, and therefore requires more sophisticated numerical solution
methods. The Lax diffusive scheme is similar to the scheme used for the
KWM in terms of the model domain discretization and initialization, but
requires additional computations at each node to obtain the
solution.</p>
<p>For an internal (non-boundary) node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
on time step
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k + 1</annotation></semantics></math>,
flow values are computed through a two step process. First, averages of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>,
and the inertial term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi>g</mi><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>S</mi><mi>f</mi></msub><mo>−</mo><msub><mi>S</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">S = gA\left(S_f - S_0\right)</annotation></semantics></math>
are computed for the node, i.e.
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>A</mi><mi>i</mi><mo>*</mo></msubsup><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mo>+</mo><msubsup><mi>A</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
A_i^* = \frac{1}{2}\left(A^k_{i+1} + A^k_{i - 1}  \right)
</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Q</mi><mi>i</mi><mo>*</mo></msubsup><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>Q</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mo>+</mo><msubsup><mi>Q</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
Q^*_i = \frac{1}{2}\left(Q^k_{i+1} + Q^k_{i - 1}  \right)
</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>S</mi><mi>i</mi><mo>*</mo></msubsup><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>S</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mo>+</mo><msubsup><mi>S</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><mi>g</mi><mi>A</mi></mrow><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><msub><mi>S</mi><mi>f</mi></msub><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mo>+</mo><msubsup><msub><mi>S</mi><mi>f</mi></msub><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mo>−</mo><mn>2</mn><msub><mi>S</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
S_i^* = \frac{1}{2}\left(S^k_{i+1} + S^k_{i - 1}\right) = \frac{gA}{2}\left({S_f}^k_{i + 1}  + {S_f}^k_{i - 1} - 2S_0\right)
</annotation></semantics></math> The values for node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
on time step
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k + 1</annotation></semantics></math>
are then calculated as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>A</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><msubsup><mi>A</mi><mi>i</mi><mo>*</mo></msubsup><mo>−</mo><mfrac><mrow><mi>Δ</mi><mi>t</mi></mrow><mrow><mn>2</mn><mi>Δ</mi><mi>x</mi></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>Q</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mo>−</mo><msubsup><mi>Q</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
A_i^{k + 1} = A_i^* - \frac{\Delta t}{2\Delta x}\left(Q^k_{i+1} - Q^k_{i-1}\right)
</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Q</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><msubsup><mi>Q</mi><mi>i</mi><mo>*</mo></msubsup><mo>−</mo><mfrac><mrow><mi>Δ</mi><mi>t</mi></mrow><mrow><mn>2</mn><mi>Δ</mi><mi>x</mi></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>F</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mo>−</mo><msubsup><mi>F</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msubsup><mi>S</mi><mi>i</mi><mo>*</mo></msubsup><mi>Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">
Q_i^{k + 1} = Q_i^* - \frac{\Delta t}{2\Delta x}\left(F^k_{i+1} - F^k_{i-1}\right) -  S_i^*\Delta t
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mi>Q</mi><mi>u</mi><mo>+</mo><mi>g</mi><mover><mi>y</mi><mo accent="true">‾</mo></mover><mi>A</mi></mrow><annotation encoding="application/x-tex">F = Qu + g\bar{y}A</annotation></semantics></math>.
To compute the flow depth
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>y</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><annotation encoding="application/x-tex">y_i^{k+1}</annotation></semantics></math>
from the new area
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>A</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><annotation encoding="application/x-tex">A_i^{k+1}</annotation></semantics></math>,
the Newton-Raphson method is again applied where
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>y</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn><mo>=</mo><mi>A</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>y</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msubsup><mi>A</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">
f(y_i^{k+1}) = 0 = A\left(y_i^{k+1}\right) - A_i^{k+1}
</annotation></semantics></math> and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>f</mi></mrow><mrow><mi>d</mi><msubsup><mi>y</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>d</mi><mi>A</mi></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><msub><mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">|</mo><msubsup><mi>y</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup></msub></mrow><annotation encoding="application/x-tex">
\frac{df}{dy_i^{k+1}} = \frac{dA}{dy} \bigg|_{y_i^{k+1}}
</annotation></semantics></math> It is clear from the derivation that
unlike the KWM solution, both the upstream and the downstream boundary
conditions must be known at each time step. The MOC described later
provides a method for predicting, rather than imposing, the downstream
boundary condition.</p>
</div>
<div class="section level3">
<h3 id="solution-to-the-dynamic-wave-model-the-maccormack-scheme">Solution to the Dynamic Wave Model: the MacCormack scheme<a class="anchor" aria-label="anchor" href="#solution-to-the-dynamic-wave-model-the-maccormack-scheme"></a>
</h3>
<p>The MacCormack scheme is an advanced finite-differencing scheme that
provides high accuracy for considerably coarser spatial and temporal
resolutions compared to the Lax diffusive scheme. The scheme consists of
a backwards-looking predictor step followed by a forward-looking
corrector step. The intermediate values calculated in the predictor step
are used to develop new intermediate values in the corrector step, and
these calculations are averaged to obtain the final value. The predictor
step computes the intermediate values at an internal node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Q</mi><mi>i</mi><mo>*</mo></msubsup><mo>=</mo><msubsup><mi>Q</mi><mi>i</mi><mi>k</mi></msubsup><mo>−</mo><mfrac><mrow><mi>Δ</mi><mi>t</mi></mrow><mrow><mi>Δ</mi><mi>x</mi></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>F</mi><mi>i</mi></msub><mo>−</mo><msub><mi>F</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msubsup><mi>S</mi><mi>i</mi><mi>k</mi></msubsup><mi>Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">
Q_i^* = Q_i^k - \frac{\Delta t}{\Delta x}\left( F_i - F_{i - 1}\right) - S_i^k \Delta t
</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>A</mi><mi>i</mi><mo>*</mo></msubsup><mo>=</mo><msubsup><mi>A</mi><mi>i</mi><mi>k</mi></msubsup><mo>−</mo><mfrac><mrow><mi>Δ</mi><mi>t</mi></mrow><mrow><mi>Δ</mi><mi>x</mi></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>Q</mi><mi>i</mi><mi>k</mi></msubsup><mo>−</mo><msubsup><mi>Q</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
A^*_i = A_i^k - \frac{\Delta t}{\Delta x}\left( Q_i^k - Q_{i-1}^k \right)
</annotation></semantics></math> with intermediate values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mo>*</mo></msup><annotation encoding="application/x-tex">F^*</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>S</mi><mo>*</mo></msup><annotation encoding="application/x-tex">S^*</annotation></semantics></math>)
computed from these results. On the corrector step, new values for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
are computed as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Q</mi><mi>i</mi><mrow><mo>*</mo><mo>*</mo></mrow></msubsup><mo>=</mo><msubsup><mi>Q</mi><mi>i</mi><mi>k</mi></msubsup><mo>−</mo><mfrac><mrow><mi>Δ</mi><mi>t</mi></mrow><mrow><mi>Δ</mi><mi>x</mi></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>F</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo>*</mo></msubsup><mo>−</mo><msubsup><mi>F</mi><mi>i</mi><mo>*</mo></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msubsup><mi>S</mi><mi>i</mi><mo>*</mo></msubsup><mi>Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">
Q_i^{**} = Q_i^{k} - \frac{\Delta t}{\Delta x}\left( F^*_{i + 1} - F^*_{i} \right) - S_i^* \Delta t
</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>A</mi><mi>i</mi><mrow><mo>*</mo><mo>*</mo></mrow></msubsup><mo>=</mo><msubsup><mi>A</mi><mi>i</mi><mi>k</mi></msubsup><mo>−</mo><mfrac><mrow><mi>Δ</mi><mi>t</mi></mrow><mrow><mi>Δ</mi><mi>x</mi></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>Q</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mo>*</mo></msubsup><mo>−</mo><msubsup><mi>Q</mi><mi>i</mi><mo>*</mo></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
A_i^{**} = A_i^k - \frac{\Delta t}{\Delta x}\left( Q_{i+1}^* - Q_i^* \right)
</annotation></semantics></math> The new values for time step
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k + 1</annotation></semantics></math>
are the arithmetic averages of the predictor and corrector step results,
i.e.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Q</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>Q</mi><mi>i</mi><mo>*</mo></msubsup><mo>+</mo><msubsup><mi>Q</mi><mi>i</mi><mrow><mo>*</mo><mo>*</mo></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Q_i^{k+1} = \frac{1}{2}\left( Q_i^* + Q_i^{**} \right)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>A</mi><mi>i</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>A</mi><mi>i</mi><mo>*</mo></msubsup><mo>+</mo><msubsup><mi>A</mi><mi>i</mi><mrow><mo>*</mo><mo>*</mo></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A_i^{k+1} = \frac{1}{2}\left( A_i^* + A_i^{**} \right)</annotation></semantics></math>.
The remaining terms are then computed from these new values.</p>
</div>
<div class="section level3">
<h3 id="solutions-to-boundary-conditions-the-method-of-characteristics">Solutions to boundary conditions: the Method of Characteristics<a class="anchor" aria-label="anchor" href="#solutions-to-boundary-conditions-the-method-of-characteristics"></a>
</h3>
<p>The DWM solution schemes provided by <code>rivr</code> require that
both the upstream and downstream boundary be known. Because the
downstream boundary is not known <em>a priori</em> under many
circumstances, the requirement would limit the utility of the numerical
schemes. The Method of Characteristics (MOC) provides a method for
predicting the downstream boundary condition at the beginning of each
time step, allowing users to route waves trhough the downstream boundary
with minimal loss of information. In addition, the method also allows
the user to specify both the upstream and downstream boundary conditions
in terms of either flow or depth, and allows specification of sudden
cessation of flow, i.e. closure of a sluice gate at the upstream or
downstream boundary.</p>
<p>MOC is a well-known concept with application to a wide variety of
numerical problems; the general theory is not presented here. It can be
shown that the upstream boundary condition (node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = 1</annotation></semantics></math>)
on time step
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
can be defined as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>u</mi><mn>1</mn><mi>k</mi></msubsup><mo>=</mo><msubsup><mi>ϕ</mi><mn>1</mn><mn>0</mn></msubsup><mo>+</mo><msubsup><mi>ψ</mi><mn>2</mn><mn>0</mn></msubsup><msubsup><mi>y</mi><mn>1</mn><mi>k</mi></msubsup></mrow><annotation encoding="application/x-tex">
u_1^k = \phi_1^0 + \psi_2^0 y_1^k
</annotation></semantics></math> where
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ψ</mi><mn>2</mn><mn>0</mn></msubsup><mo>=</mo><msqrt><mfrac><mi>g</mi><msubsup><mi>y</mi><mn>2</mn><mn>0</mn></msubsup></mfrac></msqrt></mrow><annotation encoding="application/x-tex">
\psi_2^0 = \sqrt{\frac{g}{y_2^0}}
</annotation></semantics></math> and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ϕ</mi><mn>1</mn><mn>0</mn></msubsup><mo>=</mo><msubsup><mi>u</mi><mn>2</mn><mn>0</mn></msubsup><mo>−</mo><msubsup><mi>ψ</mi><mn>2</mn><mn>0</mn></msubsup><mo>+</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>S</mi><mn>0</mn></msub><mo>−</mo><msubsup><msub><mi>S</mi><mi>f</mi></msub><mn>2</mn><mn>0</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mi>Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">
\phi_1^0 = u_2^0 - \psi_2^0 + g\left( S_0 - {S_f}_2^0 \right)\Delta t
</annotation></semantics></math> As seen from these relations, the flow
velocity and depth at the upstream boundary on any time step
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
are related to the initial conditions (i.e. 
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k = 0</annotation></semantics></math>).
The downstream boundary condition (node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">i = N</annotation></semantics></math>)
is similarly expressed as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>u</mi><mi>N</mi><mi>k</mi></msubsup><mo>=</mo><msubsup><mi>ϕ</mi><mi>N</mi><mn>0</mn></msubsup><mo>−</mo><msubsup><mi>ψ</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><mn>0</mn></msubsup><msubsup><mi>y</mi><mi>N</mi><mi>k</mi></msubsup></mrow><annotation encoding="application/x-tex">
u^k_N = \phi_N^0 - \psi_{N-1}^0 y_N^k
</annotation></semantics></math> where
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ψ</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><mn>0</mn></msubsup><mo>=</mo><msqrt><mfrac><mi>g</mi><msubsup><mi>y</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><mn>0</mn></msubsup></mfrac></msqrt></mrow><annotation encoding="application/x-tex">
\psi^0_{N-1} = \sqrt{\frac{g}{y^0_{N-1}}}
</annotation></semantics></math> and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ϕ</mi><mi>N</mi><mn>0</mn></msubsup><mo>=</mo><msubsup><mi>u</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><mn>0</mn></msubsup><mo>+</mo><msubsup><mi>ψ</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><mn>0</mn></msubsup><msubsup><mi>y</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><mn>0</mn></msubsup><mo>+</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>S</mi><mn>0</mn></msub><mo>−</mo><msubsup><msub><mi>S</mi><mi>f</mi></msub><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><mn>0</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mi>Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">
\phi^0_{N} = u^0_{N-1} + \psi^0_{N-1} y^0_{N-1} + g\left( S_0 - {S_f}^0_{N-1} \right) \Delta t 
</annotation></semantics></math> Therefore given either a flow or depth
on timestep
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>,
the upstream boundary condition can be computed as long as the initial
conditions are known. This is a notable improvement over the
normal-depth assumption of the upstream boundary condition employed in
the KWM. Flow can be routed through the downstream boundary by assuming
the gradient in flow or water level between the downstream boundary and
the nearest internal node is zero (i.e.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Q</mi><mi>N</mi><mi>k</mi></msubsup><mo>=</mo><msubsup><mi>Q</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><mi>k</mi></msubsup></mrow><annotation encoding="application/x-tex">Q^k_N = Q^k_{N-1}</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>y</mi><mi>N</mi><mi>k</mi></msubsup><mo>=</mo><msubsup><mi>y</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><mi>k</mi></msubsup></mrow><annotation encoding="application/x-tex">y^k_N = y^k_{N-1}</annotation></semantics></math>).
This results in “smearing” the solution across the downstream boundary
but is often still preferable to direct specification of flow.
Specifying the downstream boundary as a constant water depth
representing i.e. a lake or reservoir water level may also be
appropriate under many circumstances. When flow is specified at e.g. the
upstream boundary, flow depth and area are solved simultaneously using a
Newton-Raphson scheme where
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>y</mi><mn>1</mn><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mi>Q</mi><mn>1</mn><mi>k</mi></msubsup><mo>−</mo><msubsup><mi>A</mi><mn>1</mn><mi>k</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ϕ</mi><mn>1</mn><mn>0</mn></msubsup><mo>+</mo><msubsup><mi>ψ</mi><mn>2</mn><mn>0</mn></msubsup><msubsup><mi>y</mi><mn>1</mn><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">
f(y_1^k) = Q_1^k - A_1^k \left(\phi_1^0 + \psi_2^0 y_1^k\right) = 0
</annotation></semantics></math> and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>f</mi></mrow><mrow><mi>d</mi><msubsup><mi>y</mi><mn>1</mn><mi>k</mi></msubsup></mrow></mfrac><mo>=</mo><mo>−</mo><mfrac><mrow><mi>d</mi><mi>A</mi></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><msub><mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">|</mo><msubsup><mi>y</mi><mn>1</mn><mi>k</mi></msubsup></msub><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ϕ</mi><mn>1</mn><mn>0</mn></msubsup><mo>+</mo><msubsup><mi>ψ</mi><mn>2</mn><mn>0</mn></msubsup><msubsup><mi>A</mi><mn>1</mn><mi>k</mi></msubsup><mo>+</mo><msubsup><mi>y</mi><mn>1</mn><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\frac{df}{dy_1^k} = -\frac{dA}{dy}\bigg|_{y_1^k} \left( \phi_1^0 + \psi_2^0 A_1^k + y_1^k \right)
</annotation></semantics></math> Note that if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Q</mi><mn>1</mn><mi>k</mi></msubsup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">Q_1^k = 0</annotation></semantics></math>
the flow depth
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>y</mi><mn>1</mn><mi>k</mi></msubsup><annotation encoding="application/x-tex">y_1^k</annotation></semantics></math>
can be solved for directly, and if depth is supplied then the flow can
be solved for directly. The solution method for the downstream boundary
is analogous, noting that the sign of the second term in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>y</mi><mi>N</mi><mi>k</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(y^k_{N})</annotation></semantics></math>
and the corresponding term in its derivative are reversed.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Michael C Koohafkan.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

      </footer>
</div>






  </body>
</html>
